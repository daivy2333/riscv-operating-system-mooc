riscv64-unknown-elf-gcc -static -o hello hello.c
换成t1就好

然后qemu-riscv64启动,参考前两节


好的，我们来一步步解决这两个练习。

---

## **练习 5-1**

### **第一部分：反汇编 `sub x5, x6, x7` 并解析编码**

首先，我们需要对 `code/asm/sub` 文件进行反汇编。假设你已经编译了这个文件（例如使用 `riscv64-linux-gnu-gcc -o sub sub.c`），然后可以使用 `objdump` 工具：

```bash
riscv64-linux-gnu-objdump -d sub
```

在输出中找到 `sub x5, x6, x7` 对应的机器码。通常你会看到类似这样的行：

```
   1028:	43b30593	sub	x11,x6,x7
```

> 注意：寄存器编号可能因编译器优化或上下文不同而变化，但指令格式是固定的。

**但我们关心的是 `sub x5, x6, x7` 的编码。**

根据 RISC-V 规范，`sub` 是 R-type 指令，其格式如下：

```
| 31-25 | 24-20 | 19-15 | 14-12 | 11-7 | 6-0 |
| funct7| rs2   | rs1   | funct3| rd   | opcode |
```

对于 `sub` 指令：
- `funct7` = `0100000` (二进制) → 32 (十进制)
- `funct3` = `000` (二进制) → 0 (十进制)
- `opcode` = `0110011` (二进制) → 51 (十进制)

对于 `sub x5, x6, x7`：
- `rd` = x5 → 5 → 00101
- `rs1` = x6 → 6 → 00110
- `rs2` = x7 → 7 → 00111

所以完整的 32 位机器码为：

```
funct7 (7 bits) | rs2 (5 bits) | rs1 (5 bits) | funct3 (3 bits) | rd (5 bits) | opcode (7 bits)
0100000         | 00111        | 00110        | 000           | 00101       | 0110011
```

拼接起来：

```
0100000 00111 00110 000 00101 0110011
```

转换成十六进制：

从右到左每 4 位一组：

```
0110011 00101 000 00110 00111 0100000
→ 分组：
0110 0110 0101 0000 0110 0011 1010 0000
→ 6 6 5 0 6 3 A 0
```

所以机器码是：**`0x665063A0`**

但在小端序内存中存储时，字节顺序是反过来的：

```
0xA0 0x63 0x50 0x66
```

>  注意：实际反汇编结果可能因编译器和上下文不同略有差异，但格式和解析方法是一致的。

---

### **第二部分：将机器码 `b3 05 95 00` 翻译为汇编指令**

已知内存中的值为：`b3 05 95 00`，从左到右为从低地址到高地址，单位为字节。

这表示一个 32 位指令，按小端序排列，所以实际指令值是：

```
0x009505B3
```

现在我们解析这个十六进制数：

```
0x009505B3 = 00000000 10010101 00000101 10110011
```

按 RISC-V 指令格式拆分：

```
| 31-25 | 24-20 | 19-15 | 14-12 | 11-7 | 6-0 |
| 0000000 | 10010 | 10100 | 000 | 00101 | 0110011 |
```

对照 R-type 格式：

- `funct7` = `0000000` → 这是 `add` 指令（不是 `sub`，因为 `sub` 是 `0100000`）
- `rs2` = `10010` → x18
- `rs1` = `10100` → x20
- `funct3` = `000` → add/sub
- `rd` = `00101` → x5
- `opcode` = `0110011` → R-type

因为 `funct7=0000000`，所以是 **`add x5, x20, x18`**

 **答案：`add x5, x20, x18`**

---

## **练习 5-2**

给定 C 代码：

```c
register int a, b, c, d, e;
b = 1;
c = 2;
e = 3;
a = b + c;
d = a - e;
```

我们需要编写等效的汇编代码，并用寄存器存放变量，然后用 gdb 调试。

### **步骤 1：分配寄存器**

我们可以这样映射变量到寄存器（RISC-V 寄存器命名）：

- `a` → `x10` (`a0`)
- `b` → `x11` (`a1`)
- `c` → `x12` (`a2`)
- `d` → `x13` (`a3`)
- `e` → `x14` (`a4`)

> 注：也可以使用其他通用寄存器如 `x5~x7`，但 `a0-a4` 是标准参数寄存器，适合临时变量。

### **步骤 2：编写汇编代码**

创建文件 `calc.s`：

```asm
# calc.s - RISC-V assembly equivalent of the C code
.section .text
.global _start

_start:
    # b = 1
    li x11, 1

    # c = 2
    li x12, 2

    # e = 3
    li x14, 3

    # a = b + c
    add x10, x11, x12

    # d = a - e
    sub x13, x10, x14

    # 退出程序（Linux 系统调用）
    li a7, 93          # sys_exit
    li a0, 0           # exit status
    ecall

    # 程序结束
```

### **步骤 3：编译与链接**

```bash
# 编译
riscv64-linux-gnu-as -o calc.o calc.s

# 链接
riscv64-linux-gnu-ld -o calc calc.o --entry=_start

# 或者直接用 gcc（更简单）
riscv64-linux-gnu-gcc -nostdlib -o calc calc.s
```

### **步骤 4：用 GDB 调试**

```bash
riscv64-linux-gnu-gdb ./calc
```

在 GDB 中：

```gdb
(gdb) break _start
(gdb) run
(gdb) stepi
(gdb) stepi
...
(gdb) info registers x10 x11 x12 x13 x14
```

你应该看到：

- `x11 = 1` （b）
- `x12 = 2` （c）
- `x14 = 3` （e）
- `x10 = 3` （a = b + c）
- `x13 = 0` （d = a - e）

 完全符合预期！

---

##  最终答案总结：

### **练习 5-1**

1. `sub x5, x6, x7` 的机器码是 **`0x665063A0`**（大端），在内存中为 `A0 63 50 66`（小端）。
2. 机器码 `b3 05 95 00`（小端）对应汇编指令：**`add x5, x20, x18`**

### **练习 5-2**

汇编代码：

```asm
.section .text
.global _start

_start:
    li x11, 1      # b = 1
    li x12, 2      # c = 2
    li x14, 3      # e = 3
    add x10, x11, x12  # a = b + c
    sub x13, x10, x14  # d = a - e
    li a7, 93      # sys_exit
    li a0, 0
    ecall
```

使用 `gdb` 调试可验证寄存器值正确。

